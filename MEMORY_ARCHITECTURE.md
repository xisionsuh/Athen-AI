# Athena AI 메모리 아키텍처 가이드

## 개요

Athena AI는 두 가지 유형의 메모리를 구분하여 관리합니다:

1. **단기 기억 (Short-term Memory)**: 세션별 대화 내용
2. **장기 기억 (Long-term Memory)**: 사용자별 영구 정보 및 학습 데이터

## 메모리 타입별 기준

### 1. 단기 기억 (Short-term Memory) - 세션별 대화

**특징:**
- 세션(`session_id`) 단위로 저장
- 새 채팅 시작 시 **초기화됨** (UI에서 표시되지 않음)
- 대화 맥락(context) 제공에 사용
- 최근 N개 메시지만 유지 (기본값: 10개)

**저장되는 정보:**
- 사용자 메시지
- AI 응답
- 메타데이터 (전략, 사용된 AI, 검색 결과 수 등)

**사용 시점:**
- 현재 세션의 대화 맥락이 필요할 때
- 연속적인 대화 흐름 유지

**새 채팅 시작 시:**
- ❌ **과거 대화 내용을 UI에 표시하지 않음**
- ✅ **하지만 AI는 필요시 이전 세션의 맥락을 참조할 수 있음** (선택적)

---

### 2. 장기 기억 (Long-term Memory) - 사용자별 영구 정보

**특징:**
- 사용자(`user_id`) 단위로 저장
- 새 채팅 시작 시에도 **유지됨**
- Athena의 학습과 정체성 유지에 사용
- 명시적으로 삭제하지 않는 한 영구 보존

**저장되는 정보:**

#### A. 정체성 (Identity)
- Athena의 인격, 행동 방법, 판단 가중치
- 예: "친절하고 전문적인 톤 사용", "코딩 질문 시 상세한 설명 제공"

#### B. 사용자 선호도 (User Preferences)
- 사용자의 선호하는 스타일, 형식
- 예: "간결한 답변 선호", "코드 예제 포함 선호"

#### C. 프로젝트 정보 (Project Information)
- 진행 중인 프로젝트, 작업 내용
- 예: "React 프로젝트 진행 중", "Python 데이터 분석 프로젝트"

#### D. 사실 정보 (Facts)
- 사용자에 대한 중요한 사실
- 예: "서울 거주", "개발자 직업"

#### E. 학습 데이터 (Learning Data)
- AI 성능 데이터 (`ai_performance`)
- 사용자 피드백 (`debate_feedback`, `voting_feedback`)
- 의사결정 패턴 (`decision_log`)

**사용 시점:**
- 모든 새 채팅에서 자동으로 적용
- 사용자별 맞춤형 응답 생성
- Athena의 일관된 정체성 유지

**새 채팅 시작 시:**
- ✅ **모든 장기 기억이 자동으로 적용됨**
- ✅ **Athena는 사용자를 기억하고 이전 학습 내용을 활용**

---

## 구분 기준 요약

| 구분 | 단기 기억 | 장기 기억 |
|------|----------|----------|
| **범위** | 세션별 | 사용자별 |
| **저장 기간** | 세션 동안만 | 영구적 |
| **새 채팅 시** | 초기화 (UI에서 숨김) | 유지 및 적용 |
| **표시 여부** | UI에 표시됨 | UI에 표시 안 됨 (백그라운드 적용) |
| **용도** | 대화 맥락 | 정체성, 선호도, 학습 |
| **삭제** | 세션 삭제 시 | 명시적 삭제 필요 |

---

## 구현 권장사항

### 1. 새 채팅 시작 시 동작

```javascript
// ✅ 올바른 동작
async function createNewSession() {
  // 1. 단기 기억: UI 초기화 (과거 대화 숨김)
  chatMessages.innerHTML = '<div class="welcome-screen">...</div>';
  
  // 2. 장기 기억: 자동으로 적용됨 (별도 작업 불필요)
  // - 정체성(Identity)은 시스템 프롬프트에 포함
  // - 사용자 선호도는 자동으로 반영
  // - 학습 데이터는 AI 선택에 활용
}
```

### 2. 메시지 처리 시 메모리 사용

```javascript
async process(userId, sessionId, userMessage) {
  // 1. 단기 기억: 현재 세션의 맥락만 가져오기
  const context = this.memory.getContextWindow(sessionId, 10);
  
  // 2. 장기 기억: 사용자별 정보 가져오기
  const longTermMemories = this.memory.getLongTermMemory(userId, ['preference', 'project']);
  const identity = this.memory.getAllIdentity('core');
  
  // 3. 시스템 프롬프트 구성
  let systemPrompt = this.buildAthenaSystemPrompt(identity, longTermMemories);
  
  // 4. 메시지 구성 (단기 기억만 포함)
  const messages = [
    { role: 'system', content: systemPrompt }, // 장기 기억은 여기에
    ...context, // 단기 기억은 여기에
    { role: 'user', content: userMessage }
  ];
}
```

### 3. 장기 기억 저장 시점

장기 기억은 다음 상황에서 저장되어야 합니다:

1. **사용자 선호도 학습**
   - 피드백 수집 시 (`debate_feedback`, `voting_feedback`)
   - 사용자가 명시적으로 선호도 표현 시

2. **프로젝트 정보**
   - 사용자가 프로젝트 관련 정보 제공 시
   - 장기 기억 모달에서 수동 저장 시

3. **정체성 업데이트**
   - 사용자와의 상호작용을 통해 학습
   - 관리자가 수동으로 설정

---

## 사용자 경험 (UX) 관점

### 사용자가 기대하는 동작

1. **새 채팅 시작 시:**
   - ✅ 깨끗한 화면 (과거 대화 없음)
   - ✅ Athena는 사용자를 기억함 ("안녕하세요! 오늘도 도와드릴까요?")
   - ✅ 이전에 학습한 선호도 적용 (예: 간결한 답변)

2. **이전 세션으로 돌아갈 때:**
   - ✅ 해당 세션의 대화 내용 표시
   - ✅ 장기 기억도 함께 적용

3. **학습과 기억:**
   - ✅ 사용자가 "나는 간결한 답변을 좋아해"라고 말하면 장기 기억에 저장
   - ✅ 이후 모든 새 채팅에서 간결한 답변 제공

---

## 구현 체크리스트

- [x] 단기 기억: 세션별로 분리 저장
- [x] 장기 기억: 사용자별로 저장
- [x] 새 채팅 시작 시 UI 초기화
- [ ] 장기 기억을 시스템 프롬프트에 자동 포함
- [ ] 사용자 피드백을 장기 기억으로 학습
- [ ] 장기 기억 관리 UI (이미 구현됨)
- [ ] 장기 기억 검색 및 활용 로직 강화

---

## 향후 개선 방향

1. **지능형 장기 기억 추출**
   - 대화 내용에서 중요한 정보 자동 추출
   - 사용자 선호도 자동 학습

2. **장기 기억 우선순위**
   - 중요도(importance) 기반 필터링
   - 관련성 기반 검색

3. **메모리 효율성**
   - 오래된 단기 기억 자동 정리
   - 사용하지 않는 장기 기억 아카이빙

